Документ описывает основные требования и подходы к разработке микросервисов.

Термины «НЕОБХОДИМО» («ДОЛЖЕН»), «НЕДОПУСТИМО» («НЕ ДОЛЖЕН»), «ТРЕБУЕТСЯ», «НУЖНО», «СЛЕДУЕТ» («РЕКОМЕНДУЕТСЯ»), «НЕ СЛЕДУЕТ» («НЕ РЕКОМЕНДУЕТСЯ»), «ВОЗМОЖНО» («МОЖЕТ») и «НЕОБЯЗАТЕЛЬНЫЙ» («НЕОБЯЗАТЕЛЬНО») в данном документе следует интерпретировать как описано в [RFC 2119](http://rfc.com.ru/rfc2119.htm).

[Микросервис](https://ru.wikipedia.org/wiki/%d0%9c%d0%b8%d0%ba%d1%80%d0%be%d1%81%d0%b5%d1%80%d0%b2%d0%b8%d1%81%d1%8b) (здесь и далее «сервис») — это небольшой логически и физически изолированный (слабо связанный с другими сервисами) компонент, реализующий некий бизнес-функционал.

# Общие принципы
1. Сервисам СЛЕДУЕТ реализовывать функционал, соответствующий некой бизнес-потребности. Например, сервис поиска товаров или сервис хранения изображений. НЕ СЛЕДУЕТ делать сервисы слишком большими и универсальными (например, НЕ СЛЕДУЕТ реализовывать сервис веб-сайта). 
2. [Мандат Безоса](https://jesusgilhernandez.com/2012/10/18/jeff-bezos-mandate-amazon-and-web-services/) (ниже в переводе отражена суть и добавлены примеры, это не 100% точный перевод, так как никого увольнять за нарушение мандата мы не хотим):
	- Всем командам НЕОБХОДИМО предоставлять доступ к данным и функциональности только через интерфейсы сервисов.
	- Командам НЕОБХОДИМО взаимодействовать друг с другом (в смысле взаимодействия на уровне кода и приложений) только через эти интерфейсы.
	- Любые другие формы взаимодействия НЕДОПУСТИМЫ (включая, но не ограничиваясь прямыми запросами в базу данных другого сервиса/команды, использованием разделяемой памяти, обменом данными через файловую систему).
	- Вышеобозначенные требования НЕОБХОДИМО соблюдать независимо от используемых протоколов передачи информации и моделей взаимодействия (HTTP, gRPC, Corba, Pub-Sub и т.д.).
	- Все интерфейсы сервисов без исключения НЕОБХОДИМО проектировать так, чтобы при необходимости доступ к ним можно было предоставить разработчикам из внешнего мира (НЕДОПУСТИМЫ неявные соглашения уровня «вот в этом параметре всегда надо передавать 42 или работать не будет, а допустимый набор значений этого параметра знает Вася, спроси у него»).
3. Graceful degradation: в случае невозможности удовлетворения каких-либо зависимостей, требующихся для работы сервиса, сервису НЕОБХОДИМО стараться сохранить максимум функциональности. Пример:
    - Если сервис не может записать логи на диск по причине закончившегося свободного места — ему НЕОБХОДИМО продолжать работать для своих клиентов без изменений в поведении.
    - Если сервис по рендерингу HTML (фронт) не может получить от сервиса, управляющего ротацией рекламы, информацию о том, какой баннер нужно показать — фронту НЕОБХОДИМО отрендерить всю страницу за исключением блока с баннером (а не показывать пользователю страницу с ошибкой).
4. Сервисам [НЕ СЛЕДУЕТ сохранять состояние](https://ru.wikipedia.org/wiki/%d0%9f%d1%80%d0%be%d1%82%d0%be%d0%ba%d0%be%d0%bb_%d0%b1%d0%b5%d0%b7_%d1%81%d0%be%d1%85%d1%80%d0%b0%d0%bd%d0%b5%d0%bd%d0%b8%d1%8f_%d1%81%d0%be%d1%81%d1%82%d0%be%d1%8f%d0%bd%d0%b8%d1%8f) между разными запросами. Для хранения состояния СЛЕДУЕТ использовать внешнее по отношению к сервису хранилище (базу данных, файловое хранилище и т.д.).
5. Экземплярам сервиса СЛЕДУЕТ быть независимыми друг от друга и стремиться минимизировать трафик между собой.
6. Сервису НЕ ПОЗВОЛЯЕТСЯ рассчитывать на то, что его экземпляр будет запущен на каком-то определённом физическом сервере.
7. Сервису НЕОБХОДИМО иметь тесты (юнит, функциональные, интеграционные) и поддерживать их в актуальном состоянии. Тестам СЛЕДУЕТ быть небольшими, быстрыми и не зависеть от окружения, в котором они выполняются. НЕОБХОДИМО иметь покрытие нового функционала Unit-тестами. Unit-тесты — тесты, объектом тестирования которых является функция, метод класса, целый класс или сервис. Unit-тест может запускаться без компилирования сервиса. Если тест требует деплоя сервиса или вызова нескольких сервисов — это интеграционный тест. ВОЗМОЖНО использовать базу данных в Unit-тестах. НЕОБХОДИМО изолировать базу данных (например, развернуть gitlab services). НЕОБХОДИМО использовать тестовые дубли (mock, stub, spy, fake, dummy) в Unit-тестах. Покрытие Unit-тестами считается по коду. Подсчет покрытия Unit-тестами не требует инструментирования кода из вне. Покрытие Unit-тестами не отменяет необходимость покрытия интеграционными и сквозынми тестами.    
8. НЕДОПУСТИМО реализовывать бизнес-логику за пределами сервисов. То есть НЕДОПУСТИМО использование хранимых процедур, триггеров и внешних ключей (foreign keys) в реляционных базах данных. НЕДОПУСТИМО использование lua-скриптов в хранилищах типа Tarantool.

# Интерфейсы
1. Для взаимодействия с внешним миром (с интернетом) сервисам НЕОБХОДИМО использовать [REST](https://ru.wikipedia.org/wiki/REST).
2. Для взаимодействия между собой сервисам НЕОБХОДИМО использовать [gRPC](https://grpc.io/).
3. Для даты и времени в ответах и запросах сервису НЕОБХОДИМО соблюдать [RFC 3339](https://tools.ietf.org/html/rfc3339). НЕОБХОДИМО хранить (в базе данных, в любом хранилище) и передавать (интерфейсы между сервисами/компонентами/приложениями и так далее) дату и время в UTC.
   > [!example]
     `1970-01-01T12:00:00.234+00:00`. Если нужно передать только дату (без времени): `1970-01-01`.
4. НЕДОПУСТИМО в рамках открытой транзакции во внешнее по отношению к сервису хранилище (базу данных, кеш и так далее) осуществлять взаимодействие с другим сервисом. То есть НЕДОПУСТИМО открыть транзакцию, после этого сделать запрос во внешний сервис, и не закрывать транзакцию, пока не будет получен ответ от внешнего сервиса. При этом ВОЗМОЖНО параллельно выполнять транзакции во внешние хранилища и запросы во внешние сервисы, если одни не зависят от других.

# Документация
1. Всем сервисам НЕОБХОДИМО иметь документацию.
3. Каждому сервису, предоставляющему REST интерфейс, НЕОБХОДИМО предоставлять документацию в формате [Swagger JSON](https://swagger.io/specification/), доступную по `/swagger.json`

# Версионирование
1. НЕОБХОДИМО осуществлять версионирование не только всего сервиса, но и каждого его метода в отдельности.
2. Для версионирования методов НЕОБХОДИМО использовать число, являющееся номером версии.
3. НЕДОПУСТИМО изменение интерфейсов сервисов с потерей обратной совместимости. Если сохранение обратной совместимости не представляется возможным, НЕОБХОДИМО создавать новую мажорную версию метода (например, `/products/v2`).
4. Под обратной совместимостью понимается соблюдение следующих принципов:
    - Если метод реализует чтение данных из сервиса, то новая версия метода всегда возвращает не меньше сущностей, чем предыдущая (например, добавление полей в структуру ответа является обратно совместимым изменением, а удаление полей — нет).
    - Если метод реализует запись данных в сервис (создание или обновление сущностей), то новая версия метода всегда требует не больше сущностей, чем предыдущая (например, добавление необязательных параметров метода является обратно совместимым изменением, а добавление обязательных — нет).
5. По сути, для версионирования методов используется только MAJOR-версия из [семантического версионирования (SemVer)](https://semver.org/). ВОЗМОЖНО использовать также версии MINOR и PATCH, но при их изменении НЕДОПУСТИМО изменение точки входа в метод. Например, можно указывать в комментариях к методу его версию 2.1.1, при этом точка входа в метод `/products/v2`, и она остаётся такой же при изменении версии на 2.2.3.
6. НЕДОПУСТИМО связывать версии сервиса и версии его методов.
7. Сервису НЕОБХОДИМО поддерживать все версии всех своих методов до тех пор, пока существует хотя бы один клиент, способный запросить данный метод данной версии.
8. Клиентам СЛЕДУЕТ использовать только те данные, предоставляемые сервисом, которые необходимы, и игнорировать неизвестные данные.

# Протоколы

## REST
1. Если в качестве формата данных используется JSON, то в запрос и в ответ НЕОБХОДИМО добавлять HTTP-заголовок `Content-Type: application/json`. В случае передачи бинарных данных (например, загрузка файла) ВОЗМОЖНО использование соответствующего значения HTTP-заголовка `Content-Type`.
2. Для порта, по которому доступны методы, НЕОБХОДИМО использовать название `http` (для k8s) и номер `80`.
3. ВОЗМОЖНО использование [HTTP-заголовков для управления кешированием](https://www.rfc-editor.org/rfc/rfc9111.html) на стороне клиентов.
4. В случае ошибки НЕОБХОДИМО включать в ответ сервиса код ошибки и человекочитаемое сообщение об ошибке. Также ВОЗМОЖНО включение в ответ дополнительно информации.
5. НЕОБХОДИМО использовать только один из следующих HTTP-кодов в ответе:
    - **200 OK** — отсутствие ошибок.
    - **400 Bad Request** — недопустимый или неправильно сформированный запрос, который следует исправить на стороне клиента; любой запрос, нарушающий бизнес-логику (например, запрос отрицательного количества товаров).
    - **401 Unauthorized** — клиент не аутентифицирован.
    - **403 Forbidden** — клиент не авторизован для выполнения запрошенной операции.
    - **404 Not Found** — необходимо использовать в случае, когда запрашиваемая сущность не найдена (обратите внимание, что в случае, когда при запросе сущности параметры запроса имеют некорректный формат — необходимо использовать код ответа 400, а не 404).
    - **429 Too Many Requests** — клиент отправил слишком запросов за определённый промежуток времени и сработал rate-limiter.
    - **500 Internal Server Error** — ошибка на стороне сервиса (например, ошибка базы данных, используемой сервисом, или таймаут какой-либо операции внутри сервиса).
    
    ВОЗМОЖНО использование других HTTP-кодов ответа в случае, если того требуют контракты с внешними (не находящимися во внутренней сети и не разрабатываемыми сотрудниками компании) сервисами.
    
    Коды ответа используются при расчете стабильности, но только часть из них (✘) являются ошибками самого сервиса и учитываются как негативные.
    
    |Код|«Стабильный» код|
    |---|---|
    |1xx|![✔](https://fonts.gstatic.com/s/e/notoemoji/15.1/2714/32.png)︎|
    |2xx|![✔](https://fonts.gstatic.com/s/e/notoemoji/15.1/2714/32.png)︎|
    |3xx|![✔](https://fonts.gstatic.com/s/e/notoemoji/15.1/2714/32.png)︎|
    |4xx|![✔](https://fonts.gstatic.com/s/e/notoemoji/15.1/2714/32.png)︎|
    |5xx|✘|

6. НЕОБХОДИМО использовать только следующие HTTP-методы: GET, POST, PUT, DELETE, OPTIONS. Эти методы НЕОБХОДИМО применять в соответствии со [стандартом HTTP/1.1](https://www.rfc-editor.org/rfc/rfc9110.html#name-method-definitions).
    
    |HTTP-метод|GET|POST|PUT|DELETE|
    |---|---|---|---|---|
    |CRUD-операция|READ|CREATE|UPDATE|DELETE|
    |Поведение для `/products`|Показать список продуктов|Создать несколько продуктов|Обновить несколько продуктов|Удалить несколько продуктов|
    |Поведение для `/products/123`|Показать продукт №123|Ошибка|Обновить продукт №123, если такой существует. Создать продукт №123, если такой не существует и передано достаточно данных для создания.|Удалить продукт №123|
    
7. РЕКОМЕНДУЕТСЯ генерировать REST-интерфейс на основе `.proto`-файла, описывающего gRPC-интерфейс, при этом соблюдать [proto JSON mapping](https://developers.google.com/protocol-buffers/docs/proto3#json). Для сервисов на Go РЕКОМЕНДУЕТСЯ использовать библиотеку [grpc-gateway](https://github.com/grpc-ecosystem/grpc-gateway).
8. Примеры запросов и ответов:
> [!example]
>```
>     --> GET /products/v2/
>     <-- [
>         {"product_id":"1234", "title":"iphone"},
>         {"product_id":"5678", "title":"android"}
>     ]
>
>     --> GET /products/v2/
>     <-- {"error": {"code": 12345, "message": "error message", "data": {"field1":"value1", "field2":"value2"}}}
> ```
9. Примеры хороших REST API: [GitHub API v3](https://developer.github.com/v3/), [PayPal REST API](https://developer.paypal.com/docs/api/overview/).

## gRPC
1. НЕОБХОДИМО поддерживать [gRPC reflection](https://godoc.org/google.golang.org/grpc/reflection).
2. НЕОБХОДИМО соблюдать [Style Guide](https://developers.google.com/protocol-buffers/docs/style).
3. В каждом `.proto`-файле НЕОБХОДИМО добавлять:
	- директиву `package`
	- опцию `go_package`
	- опцию `csharp_namespace`
4. Поддерживаемые форматы импортов `.proto`-файлов.
    
    Поскольку в большинстве сервисов используются инструменты для вендоринга внешних `.proto`-зависимостей, НЕОБХОДИМО соблюдать определённый формат импортов.
    
    Поддерживаются следующие типы импортов:
    
    - Well Known Types:
		- Built-in [google/protobuf](https://gitlab.ozon.ru/platform/fork-protocolbuffers/-/tree/master/src/google/protobuf),
		- Семейство googleapis [google/*](https://gitlab.ozon.ru/platform/fork-googleapis/-/tree/master/google),
		- Swagger [protoc-gen-swagger/*](https://gitlab.ozon.ru/platform/fork-grpc-gateway/-/tree/master/protoc-gen-openapiv2),
		- Openapiv2 [protoc-gen-openapiv2/*](https://gitlab.ozon.ru/platform/fork-grpc-gateway/-/tree/master/protoc-gen-openapiv2).
    - FQDN импорты формата `hostname`/`путь внутри репозитория`. Например, `[gitlab.ozon.ru/platform/proto/api/annotations.proto](http://gitlab.ozon.ru/platform/proto/api/annotations.proto)`. Такой формат может использоваться в том числе и для локальных импортов.
    - Относительные локальные импорты (будет использоваться первый найденный файл):
        - Путь на уровне той же директории, что и основной `.proto`-файл.
    
            ```
            ├── dir
            │  └── proto2.proto
            └── proto1.proto
            ```
    
            ```
            // proto1.proto
            import "dir/proto2.proto"
            ```

        - Путь относительно корня репозитория.

5. Пример `.proto`:
> [!example]
>   ```proto
>     // gitlab.ozon.ru/bx/catalog-api/api/foo/foo.proto
>     syntax = "proto3";
>        
>     // При формировании package:
>     // - gitlab.ozon.ru заменяется на ozon
>     // - все "/" заменяются на "."
>     // - все "-" заменяются на "_"
>     package ozon.bx.catalog_api.api.foo;
>        
>     // Подробнее про формирование go_package можно почитать здесь: https://developers.google.com/protocol-buffers/docs/reference/go-generated
>     option go_package = "gitlab.ozon.ru/bx/catalog-api/pkg/foo";
>     option csharp_namespace = "Ozon.Bx.CatalogApi.Foo";
>         
>     // CamelCase используется в имени сервиса
>     service FooService {
>         // CamelCase используется в названиях методов и сообщений
>         rpc GetProducts (GetProductRequest) returns (GetProductResponse);
>     }
>        
>     message GetProductRequest {
>         // snake_case используется в названиях полей
>         uint64 product_id = 1;
>     }
>        
>     message GetProductResponse {
>         uint64 product_id = 2;
>         // если в названии поля есть цифра, она не отделяется подчёркиванием
>         string title1 = 3;
>         string title2 = 4;
>     }
> ```
    
6. Сервис ДОЛЖЕН возвращать любой код ответа из [списка](https://grpc.github.io/grpc/core/md_doc_statuscodes.html), но только часть из них (✘) являются ошибками самого сервиса и учитываются при расчёте стабильности.
    
    |Код|Номер|«Стабильный» код|
    |---|---|---|
    |OK|0|![✔](https://fonts.gstatic.com/s/e/notoemoji/15.1/2714/32.png)︎|
    |CANCELLED|1|![✔](https://fonts.gstatic.com/s/e/notoemoji/15.1/2714/32.png)︎|
    |UNKNOWN|2|✘|
    |INVALID_ARGUMENT|3|![✔](https://fonts.gstatic.com/s/e/notoemoji/15.1/2714/32.png)︎|
    |DEADLINE_EXCEEDED|4|![✔](https://fonts.gstatic.com/s/e/notoemoji/15.1/2714/32.png)︎|
    |NOT_FOUND|5|![✔](https://fonts.gstatic.com/s/e/notoemoji/15.1/2714/32.png)︎|
    |ALREADY_EXISTS|6|![✔](https://fonts.gstatic.com/s/e/notoemoji/15.1/2714/32.png)︎|
    |PERMISSION_DENIED|7|![✔](https://fonts.gstatic.com/s/e/notoemoji/15.1/2714/32.png)︎|
    |RESOURCE_EXHAUSTED|8|![✔](https://fonts.gstatic.com/s/e/notoemoji/15.1/2714/32.png)︎|
    |FAILED_PRECONDITION|9|![✔](https://fonts.gstatic.com/s/e/notoemoji/15.1/2714/32.png)︎|
    |ABORTED|10|![✔](https://fonts.gstatic.com/s/e/notoemoji/15.1/2714/32.png)︎|
    |OUT_OF_RANGE|11|![✔](https://fonts.gstatic.com/s/e/notoemoji/15.1/2714/32.png)︎|
    |UNIMPLEMENTED|12|![✔](https://fonts.gstatic.com/s/e/notoemoji/15.1/2714/32.png)︎|
    |INTERNAL|13|✘|
    |UNAVAILABLE|14|✘|
    |DATA_LOSS|15|✘|
    |UNAUTHENTICATED|16|![✔](https://fonts.gstatic.com/s/e/notoemoji/15.1/2714/32.png)︎|

7. Для передачи денежных значений НЕОБХОДИМО использовать тип данных [Money](https://github.com/googleapis/googleapis/blob/master/google/type/money.proto
> [!example]
>```proto
> message PriceResponse {
>   google.type.Money price = 1;
> }
> ```
9. Для передачи даты и времени НЕОБХОДИМО использовать соответствующие типы данных:
	- [Timestamp](https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/timestamp.proto) - момент времени в UTC;
	- [Date](https://github.com/googleapis/googleapis/blob/master/google/type/date.proto) - календарная дата;
	- [DateTime](https://github.com/googleapis/googleapis/blob/master/google/type/datetime.proto) - дата и время с указанием временной зоны или смещением относительно UTC.
> [!warning]
> НЕДОПУСТИМО использовать строки для передачи даты и времени.

## GraphQL
1. GraphQL ВОЗМОЖНО использовать для доступа к данным из пользовательского интерфейса.
2. Взаимодействие по GraphQL между сервисами ЗАПРЕЩЕНО.
3. Для порта, по которому доступны методы, НЕОБХОДИМО использовать название `http` (для k8s) и номер `80`.
4. Все GraphQL запросы ДОЛЖНЫ обрабатываться по пути (entrypoint) `/gql`.
5. [Схема данных](https://graphql.org/learn/schema) в формате [Introspection Query](https://graphql.org/learn/introspection) ДОЛЖНА быть доступна на debug-порту по пути `/schema-gql`.
6. [Документация](https://github.com/graphql/graphiql) ДОЛЖНА быть доступна на debug-порту по пути `/docs-gql`.

# Безопасность
1. Сервису НЕ ПОЗВОЛЯЕТСЯ рассчитывать на то, что данные, поступающие к нему на вход, являются безопасными. НЕОБХОДИМО позаботиться о валидации входных данных внутри сервиса.
2. В сервисах, осуществляющих формирование HTML-содержимого, НЕОБХОДИМО делать кодирование и экранирование данных. Экранирование НЕОБХОДИМО выполнять непосредственно перед выводом данных. То есть в хранилище (базе данных) НЕОБХОДИМО хранить неэкранированные данные. НЕДОПУСТИМО при выводе данных рассчитывать на то, что полученные из хранилища данные уже экранированы (за исключением случаев, когда выводимые данные кешируются).
3. Сервису НЕОБХОДИМО проверять авторизацию при работе с объектами (см. Небезопасные прямые указатели на объекты (**IDOR**)).
4. Сервису НЕОБХОДИМО иметь тесты (юнит, функциональные, интеграционные) для проверки авторизации при работе с объектами и поддерживать их в актуальном состоянии.
5. НЕДОПУСТИМО хранить секреты (например, пароли, API-ключи или другие токены) в коде сервиса.
6. Уязвимости в добавленной сторонней библиотеке — это уязвимости вашего сервиса.    
7. Если для взаимодействия с внешним миром (с интернетом) сервис использует REST, то НЕДОПУСТИМО использовать GET-метод для изменения каких-либо данных.
8. Если в сервисе осуществляется скачивание чего-либо по URL-адресу от пользователя, то НЕОБХОДИМО предусмотреть защитные меры от атак вида SSRF в соответствие с Межсерверная подделка запросов (**SSRF**).
9. НЕДОПУСТИМО писать в лог сервиса в чистом виде какие-либо токены доступа (например, access-token или API-key). При необходимости наличия этих данных НЕОБХОДИМО сделать их маскирование.

# Методы

## /live /ready
Хендлеры, используемые для [liveness/readiness probe в k8s](https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes).

Несмотря на то, что kubernetes предоставляет несколько механизмов для реализации probe, сервисы ДОЛЖНЫ использовать только HTTP probes.

С точки зрения самого сервиса probe может быть в одном из двух состояний:
- Включена. Хендлер возвращает HTTP-код в диапазоне \[200, 400).
- Выключена. Хендлер возвращает любой код, отличный от диапазона \[200, 400).

### Liveness probe
Liveness probe ДОЛЖНА возвращать ошибку только в том случае, если наступила проблема, которая препятствует обработке запросов и может быть решена только рестартом сервиса. Liveness probe ДОЛЖНА быть всегда включена.
### Readiness probe
Readiness probe отвечает за то, готов ли сервис обрабатывать запросы или нет. НЕДОПУСТИМО добавлять в readiness probe любые внешние зависимости, т.к. это может привести к каскадному падению всех систем. Сервис ДОЛЖЕН уметь корректно обрабатывать недоступность любой зависимости.

Readiness probe ДОЛЖНА оставаться выключенной до тех пор, пока не будет запущен gRPC-сервер.

Самое частое применение readiness probe — прогрев кеша или загрузка необходимых данных для работы при старте приложения. На время загрузки readiness probe ДОЛЖНА возвращать ошибку.

ДОПУСТИМО временно выключать readiness probe в приложении для проведения диагностики (во время инцидентов).

После получения SIGTERM сервисом, readiness probe ДОЛЖНА возвращать ошибку.

Для детализации может быть использован вызов с параметром `?full=1`. В этом случае в теле ответа можно увидеть JSON с информацией о том, какой чекер завершился ошибкой:

```
{
  cordon: "OK",
  realtime-config: "OK",
  started: "OK",
  term: "OK"
}
```

## /version
```
{
  "app_name": "some_api",
  "app_version": "version",
  "platform_name": "GO",
  "platform_version": "v1.10.3",
  "vcs_name": "GIT",
  "vcs_revision": "d3c19ee",
  "vcs_summary": "branch: feature_1 ; git-log: -",
  "build_date": "2018-07-27T10:27:52+00:00",
  "start_date": "2018-07-27T10:27:52+00:00"
}
```

## /swagger.json
Документация по методам сервиса в формате [Swagger JSON](https://swagger.io/specification/).

Метод НЕОБХОДИМО реализовывать только в случае, если сервис предоставляет [REST](https://committee.t.o3.ru/committee/services/#rest) интерфейс.

## /docs 
Документация по методам сервиса для пользователя в виде [Swagger UI](https://swagger.io/tools/swagger-ui/).

Метод НЕОБХОДИМО реализовывать только в случае, если сервис предоставляет [REST](https://committee.t.o3.ru/committee/services/#rest) интерфейс.

## /metrics
Экспорт метрик для Prometheus.

## /channelz
Информация о внутреннем состоянии gRPC-соединений в виде [channelz](https://grpc.io/blog/a-short-introduction-to-channelz/).

## /debug/pprof
Go: [pprof](https://pkg.go.dev/net/http/pprof).

# Метрики и мониторинг
1. Если сервис обслуживает входящие запросы, НЕОБХОДИМО предоставлять метрики обработки запросов (независимые от протокола): RPS, Response Time, Error Rate.
2. Если сервис делает внешние вызовы в другие сервисы, использует БД, кеширование — сервису СЛЕДУЕТ предоставлять отдельные метрики для каждого из этих случаев.
3. Метрикам сервиса НЕОБХОДИМО быть доступными по `HTTP GET /metrics` в формате Prometheus по **debug-порту**.
4. В именовании метрик РЕКОМЕНДУЕТСЯ придерживаться шаблона `<где><что><единицы_измерения>`. Пример: `database_query_duration_seconds`.
5. В качестве значений лейблов НЕДОПУСТИМО использовать значения с высокой кардинальностью: user_agent, ID, URL и т.д. Допустимая вариативность — 50 значений.

# Логирование
1. Каждому сервису НЕОБХОДИМО либо писать логи, либо отправлять трассировку.
2. РЕКОМЕНДУЕТСЯ использование и логов, и трассировки.
3. Если сервис пишет логи ему НЕОБХОДИМО писать их в STDOUT.
4. В качестве формата логов НЕОБХОДИМО использовать структурированный JSON.
5. Если по какой-то причине данные для обязательного поля отсутствуют, в лог НЕОБХОДИМО записать пустое значение, например `"message": ""`.
6. Если не указано иное (разовая ручная отладка, или см. следующий пункт), то сервису НЕОБХОДИМО логировать все сообщения уровня WARNING и ниже (ниже в смысле численное представление уровня меньше).
7. НЕОБХОДИМО в случае наличия во входящем запросе заголовка `log-level` устанавливать уровень логирования в сервисе в рамках обработки данного запроса в значение, указанное в заголовке. Например: во входящем запросе указано `log-level: info` или `log-level: 6` — это означает, что сервис должен писать в лог все сообщения уровня INFO и ниже, при этом сообщения уровня DEBUG писаться в лог не должны.
> [!example]
> ```
> {"ts": "2018-03T13:24:59.321", "message": "Your message", "level": "INFO", "trace_id":"1a93a60e17efa0bd" , "span_id":"7cbc711c34a1f44d"}
> ```

## Трассировка
1. Сервису НЕОБХОДИМО поддерживать трассировку как минимум на уровне запросов (создавать span перед получением нового запроса и завершать после записи ответа в клиента).
2. Сервису НЕОБХОДИМО поддерживать пробрасывание tracing-заголовков во все внешние запросы к другим сервисам. Для инструментирования сервиса НЕОБХОДИМО использовать OpenTracing ([https://opentracing.io/](https://opentracing.io/)).
3. Для записи трейсов сервису НЕОБХОДИМО использовать локальный Jaeger-агент, адрес которого пробрасывается в контейнер через ENV-переменные `JAEGER_AGENT_HOST`, `JAEGER_AGENT_PORT`.
4. Для выбора стратегии семплирования сервису СЛЕДУЕТ использовать remote-стратегию, а адрес Jaeger Sampler Manager брать из ENV-переменной `JAEGER_SAMPLER_MANAGER_HOST_PORT`.
5. Сервису НЕОБХОДИМО поддерживать заголовок `sample-trace: true` для принудительной записи трейсов или использовать готовые платформенные библиотеки.

# Конфигурирование

Сервис должен поддерживать динамическое конфигурирование

# Контейнеризация
1. НЕДОПУСТИМО в качестве [ENTRYPOINT](https://docs.docker.com/glossary/?term=ENTRYPOINT) или [CMD](https://docs.docker.com/glossary/?term=ENTRYPOINT) контейнера использовать что-то иное, кроме демона сервиса (например, supervisor).
2. НЕДОПУСТИМО запускать cron-скрипты в контейнерах: если нужно периодически запускать таски, НУЖНО использовать [Kubernetes CronJob](https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/).
3. НЕДОПУСТИМО запускать посторонние процессы в контейнере, которые напрямую не относятся к выполнению задач микросервиса.

# CronJob
1. Время работы CronJob НЕ ДОЛЖНО превышать интервал запуска. РЕКОМЕНДУЕТСЯ не допускать времени работы CronJob более половины интервала запуска.
2. Если время работы CronJob больше половины интервала запуска, то такой функционал СЛЕДУЕТ реализовать в виде постоянно работающего сервиса.
3. НЕДОПУСТИМО запускать CronJob чаще, чем раз в 1 минуту. РЕКОМЕНДУЕТСЯ устанавливать периодичность запуска более 1 минуты.
4. НЕДОПУСТИМО полагаться на гарантированность запуска CronJob и точность времени запуска.


# Гарантии доставки сообщений
## At Most Once Delivery
Часть сообщений могут быть не доставлены, часть доставлены повторно.

Самая простая гарантия доставки достигается установкой автокоммита оффсета в Kafka. Потеряны будут те сообщения, чей оффсет уже закоммитился, но до приёмника сообщения не были доставлены (например, из-за остановки сервиса).

Использовать этот уровень гарантии доставки ДОПУСТИМО, только если сообщения можно терять без ущерба для бизнес-процессов.

## At Least Once Delivery
Ключевая гарантия доставки: доставляются все сообщения, возможны дубли.

Продьюсер отправляет из источника сообщения в Kafka, после подтверждения отправки помечает в источнике сообщения как отправленные. Возможна повторная отправка сообщений в топик, если в Kafka они попали, но в источнике не удалось пометить как отправленные. Консьюмер читает сообщения, отправляет их на принимающую сторону и после подтверждения отправки коммитит оффсет в Kafka. Повторная отправка в приёмник возможна, если не удалось закомитить оффсет.

РЕКОМЕНДУЕТСЯ использовать как минимум этот уровень гарантии доставки.

## Exactly Once Delivery
Все сообщения доставляются ровно 1 раз. Нет потерь, нет дублей.

Этот уровень является расширением предыдущего, отсекающим дубли. На стороне источника ДОЛЖЕН генерироваться уникальный ключ сообщения, который отправляется вместе с сообщением в Kafka. На стороне приёмника для дедупликации сообщений НЕОБХОДИМО использовать именно ключ от источника.

## Общее требование к приемнику
При любой гарантии доставки сообщения в Kafka-топике могут дублироваться, поэтому любой приёмник ДОЛЖЕН гарантировать идемпотентность. То есть приёмник должен быть готовым к обработке любого количества дублей сообщений.
