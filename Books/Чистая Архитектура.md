---
authors: Роберт Мартин
title: Чистая Архитектура
aliases:
year: 2018
edition:
tags:
date: 2023-08-07
read: true
---

# Парадигмы программирования

## Структурное
Ограничение прямой передачи управления. Замена свободных переходов (например: goto) на структурные конструкции (например:  if/else, try/catch, foreach и т.п).

## Объектно-ориентированное
Ограничение на косвенную передачу управления. Замена "плоского" кода на код упакованный в некие сущности инкапсуляции.
- [[ООP+#Инкапсуляция]]
- [[ООP+#Наследование]]
- [[ООP+#Полиморфизм]]

## Функциональное
Ограничение на присваивание. Замена изменения внутреннего состояния на пересоздание новых объектов.
- Переменные не изменяются (immutable)
- Транзакционная память --> транзакционные изменения
- события и регистрация событий


# Принципы дизайна SOLID
#solid

> [!info] Цель
> - терпимость к изменениям
> - простота и понятность
> - основа для широкого использования программных компонентов

Использовать SOLID не только для построения классов, но и для строения компонентов, модулей и систем

Использовать абстрактные фабрики (переместить конструкции if/else с перебором большого количества вариантов в одно место)

**Стабильные абстракции**
- не ссылайтесь на конкретные изменчивые классы
- не наследуйтесь от конкретных изменчивых классов
- не переопределяйте конкретные функции
- никогда не ссылайтесь на имена конкретных и изменчивых сущностей

## Single Responsible Principe #SRP
**Принцип единственной ответственности** - *программные сущности* должны иметь только одну причину для изменения
> [!warning] Признак нарушения
> непреднамеренное дублирование или слияние

## Open-Closed Principe #OCP
**Принцип открытости-закрытости** - *программные сущности* должны быть открыты для *расширения* и закрыты для *изменения*
- Управление направлением ([[Dependency Injection]])
- Сокрытие реализации (интерфейсы)

## Liskov Substitution Principe #LSP
**Принцип подстановки Лискова** - если `q(x)` является свойством, верным относительно объектов `x` некоторого типа `T`, тогда `q(y)` также должно быть верным для объектов `y` типа `S`, где `S` является подтипом типа `T`

## Interface Segregation Principe #ICP
**Принцип разделения интерфейса** - *программные сущности* не должны зависеть от методов, которые они не используют

## Dependency Inversion Principe #DIP
**Принцип инверсии зависимостей** - *программные сущности* верхних уровней не должны зависеть от *программные сущности* нижних уровней. Оба типа *программные сущности* должны зависеть от абстракций.
Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
> #SAP + #SDP = #DIP


# Принципы организации компонентов

## Связность компонентов

### Reuse/Release Equivalence Principle #REP
**Принцип эквивалентного повторного использования и выпусков** - единица повторного использования есть единица выпуска

### Common Closure Principle #CCP
**Принцип согласованного изменения** - в один компонент должны включаться классы, изменяющиеся по одной причине и в одно время

### Common Reuse Principle #CRP
**Принцип совместного повторного использования** - не вынуждайте пользователей компонента зависеть от того что им не требуется

![[component_coupling.drawio.svg]]


## Сочетаемость компонентов

### Acyclic Dependencies Principe #ADP
**Принцип ацикличности зависимостей** - в графе зависимостей между пакетами не должно быть циклов
- [[Dependency Injection|инверсия зависимостей]]
- еженедельные сборки -> ночные сборки

### Stable Dependencies Principe #SDP
**Принцип устойчивых зависимостей** - зависимости должны быть направлены в сторону устойчивости ($I\to0$)
- [[Dependency Injection|инверсия зависимостей]]
- абстрактные компоненты

> **Мера устойчивость**
> $$I = \frac{F_{out}}{F_{out} + F_{in}}$$
> $F_{out}$ - исходящие зависимости
> $F_{in}$ - входящие зависимости

### Stable Abstractions Principe #SAP
**Принцип устойчивых абстракций** - устойчивость компонента пропорциональна его абстрактности

> **Мера абстрактности**
> $$A = \frac{N_C}{N_A}$$ 
> $N_C$ - число классов в компоненте,
> $N_A$ - число абстрактных классов и интерфейсов в компоненте

### Главная последовательность
![[1dq06uddhrif323kzrg2ymdlgwa.png]]

> **Удаленность от главной последовательности**
> $$D = |A + I - 1|$$
> Наиболее оптимальная состояние системы: $D\sim0$


# Архитектура

> [!info] Цель
> упростить разработку, развертывание и сопровождение

> [!info] Стратегия
> как можно дольше иметь как можно больше вариантов

Режимы разделения
- уровень исходного кода (классы, модули)
- уровень развертывания (пакеты, библиотеки)
- уровень служб (независимые программы)

Проведение границ разделения
- плагины
- бизнес-правила / UI / DB

Политика и уровень

Бизнес-правила
- сущность

> [!danger] Кричащая архитектура
> фреймворки - это инструменты а не образ жизни

> [!success] Чистая архитектура
> - независимость от фреймворков, библиотек
> - простота тестирования
> - независимость от пользовательского интерфейса
> - независимость от баз данных
> - независимость от любых внешних агентов
> - зависимости направленны внутрь, в сторону высокоуровневых политик ([[Чистая Архитектура#Сочетаемость компонентов]])

> **Шаблон "Скромный объект"**
> Разделение объекта на простой и сложный, относительно их тестирования

## Луковая модель
![[0_Ni5eUGR3MK45c8nX.webp]]

Программные сущности | Слой модели
--- | ---
services | Interface Adapters
domain services | Application Business Rules
repository interfaces | Application Business Rules

### Границы
увеличение границ между слоями луковой модели приводит к
- увеличению гибкости
- увеличение трудозатрат

> [!info] Работа архитектора
> баланс гибкости и трудозатрат

## Чистая встраиваемая архитектура

Уровень | Слои
:-: | :-:
top | <br>Программное обеспечение<br><br>
. | #OSAL OS application layer
. | <br>Операционная система<br><br>
. | #HAL Hardware application layer
. | <br>Микропрограммы<br><br>
bottom | <br>Оборудование<br><br>


# Детали

БД - это деталь
Веб - это деталь
Фреймворк - это деталь

**Недостающая глава**
- установка по уровням
- установки по компонентам
- установка по особенностям
