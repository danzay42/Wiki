#Роберт_Мартин

# Предисловие

Джеймс О.Коплин, ссылаясь на датскую коробочку со сладостями Ga-Jol, воспроизводит высказывание, "Главное кроется в деталях" или как-то так (эта фраза настолько является народной мудростью, что имеет тысячи разных форм в разных народах, культурах и профессиональных сленгах).

Есть отсылка к культуре производства Японии, с их отлаженными производственными и бизнес процессами. Есть отсылки к SCRUM и Agile, как реализации культуры производства в рамках IT сферы.

**Философия 5S**
- Сейри - организация
- Сэйтон (привет Supreme Commander) - аккуратность
- Сейсо (а вот и аниме) - чистка (мб это порядок)
- Сейкэцу - стандартизация
- Сюцуке - дисциплина

**Вывод**
Опираясь на изложенную фразу и культуру производства, автор указывает на эффективность поддержания чистого когда и архитектуры, повышающего качество, надежность IT-продуктов.

# Чистый код

> Закон Леблана: Потом равносильно никогда.

В случае плохой архитектуры и с ростом кодовой базы наступает момент, когда производительность написания нового кода падает до такого уровня, что разработчики требуют переработки архитектуры.

Признаки чистого кода
1. элегантный, эффективный, целенаправленный
2. удобочитаемый, прямолинейный, "полон четких абстракций"
3. читается и совершенствуется другими разработчиками, тестируемый
4. улучшенный до предела (тщательно написанный)
5. отсутствие дублирования
6. модуль делает то, что мы ожидали

> Постарайтесь оставить этот мир лучше, чем он был до вашего прихода

# Именование

Классы - объекты
Функции - действия

# Функции

- При разбиении на под-функции учитывать эквивалентный уровень абстракции
> => Один уровень абстракции на функцию
- Чтение кода сверху-вниз: правило **понижения**

# Комментарии

Лучшие комментарии - их ***отсутствие***

# Форматирование

- Писать вертикально, сверху -> вниз
- Стараться группировать связные и близкие по смыслу функции и данные

# Объекты и структуры данных

- Процедурный код
	- легче добавлять функции
	- сложнее добавлять структуры данных
- ОО код
	- легче добавлять новые классы
	- сложнее добавлять новые функции

> ***Закон Деметры (объекты)***
> Функция ***f*** класса ***C*** ограничена:
> - ***С***
> - объекты создание в ***f***
> - объекты, переданные в ***f***
> - объекты, экземпляра ***С***

Гибриды объектов и структур - ***ПЛОХО***
Объекты передачи данных (***DTO***) - ***ХОРОШО***


# Обработка ошибок

- Определять классы исключений для модуля
- Не возвращать null


# Тестирование

- Писать учебные тесты на используемые модули
- ***TDD***
	- не пишите код продукта без отказного теста
	- не раздувайте отказной тест
	- не пишите код больше необходимого для отказного теста
- Построение - Операция - Проверка
- Одна концепция на тест
- ***FIRST***
	- быстрота
	- независимость (друг от друга)
	- повторяемость (от среды)
	- очевидность (результат - логический признак)
	- своевременность (перед необходимым кодом продукта)


# Классы

- Компактные
- Принцип единой ответственности (==S==OLID)
- Баланс связности
- Открыты для реализации, но закрыты для модификации (S==O==LID)


# Системы

- Отделение конструирования системы от системы от использования
> => Рефакторинг после завершения разработки
- Отложенная инициализация
> Пример: DI контейнеры в golang ([uber-go/fx](https://github.com/uber-go/fx)) имеют одолженную инициализацию
- Фабрики
- Внедрение зависимостей
- Системы постоянно расширяются -> правильное распределение ответственности


# Архитектура

"Простая" (от менее к более важному)
1. Обеспечивает прохождение всех тестов
2. Не содержит дублирующего кода
3. Выражает намерения программиста
4. Использует минимальное количество классов и методов


# Многопоточность

Мифы
- многопоточность всегда повышает быстродействие
- реализация многопоточности не меняет архитектуру программы
- при работе с контейнером?, разбираться в многопоточности не обязательно

Реальность
- многопоточность требует небольшие затраты в производительности
- значительные затраты в проектировании
- значительная сложность тестирования
- фундаментальные изменения в стратегии

Реализация
- Отделение "что" от "когда"
- Отделять код многопоточности от основного кода
- Жестко следить за инкапсуляцией общих данных
- Разбивать данные на независимые подмножества

Модели выполнения
- производитель - потребитель
- читатель - писатель
- обедающие философы

Тестирование
- Отладка основного кода -> постепенное наращивание тестируемых потоков


# Рефакторинг

```mermaid
flowchart LR
A(Написание работоспособного кода) --> B(Рефакторинг)
B --> A
```


# Запахи и эвристические правила

#todo